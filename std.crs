bundle Resolution
  Number width
  Number height

bundle MousePosition
  Number x
  Number y

choice Key
  space
  enter
  ...

choice MouseButton
  left
  right
  middle

Resolution get_resolution()
MousePosition get_mouse_position()
Bool is_key_pressed(Key key)
Bool is_mouse_button_pressed(MouseButton mouse_button)

bundle Date
  Number year
  Number month
  Number day

bundle Time
  Number hour
  Number minute
  Number second

Number seconds_since_start()
Date get_current_date()
Time get_current_time()

{K:V} join([{K:V}] maps)
[T] join([[T]] lists)
{T} join([{T}] sets)

Number size({K:V} map)
Number size([T] list)
Number size({T} set)

add({K:V} map, K key, V value)
add([T] list, T item)
add({T} set, T item)

extend({K:V} map, {K:V} other_map)
extend([T] list, [T] other_list)
extend({T} set, {T} other_set)

remove({K:V} map, K key)
remove([T] list, Number index)
remove({T} set, T item)

V get({K:V} map, K key)
T get([T] list, Number index)

set({K:V} map, K key, V value)
set([T] list, Number index, T value) // assert(length(list) > index)

has({K:V} map, K key)
has([T] list, T item)
has({T} set, T item)

[K] to_key_list({K:V} map)
[V] to_value_list({K:V} map)
[T] to_list({T} set)

assert(Bool condition)

print([Number] text)
  [Number] text = clone(text)
  add(text, '\n')
  // TODO: Write text to linear memory
  // TODO: Call fd_write

Number realloc(Number pointer, Number size)

Number alloc(Number size)
  return realloc(0, size)

free(Number pointer)
  realloc(pointer, 0)

[Number] format(Number number)
[Number] format(Number number, Number base)
[Number] format(Number number, Number base, Number digits)
[Number] format(Bool bool)
[Number] format({Any:Any} map)
[Number] format([Any] list)
[Number] format({Any} set)

Number clone(Number number)
Bool clone(Bool bool)
{T} clone({T} set)
[T] clone([T] list)
{K:V} clone({K:V} map)

// Formatting is baked into the syntax, no formatter necessary. Only one way to write any given piece of code.
// Super easy generics and metaprogramming?
// Every variable is a mutable reference. A.K.A. everything is a i32 pointing into linear memory. Yes this is inefficient. Cry about it.
// One indexed
// Untyped bindings
// Overloading
// Generics
